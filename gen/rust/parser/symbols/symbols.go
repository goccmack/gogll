//  Copyright 2020 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Package symbols generates Rust code for parser symbols
package symbols

import (
	"bytes"
	"text/template"

	"github.com/goccmack/gogll/ast"
	"github.com/goccmack/goutil/ioutil"
)

type Data struct {
	NonTerminals     []string
	Terminals        []string
	EscapedTerminals []string
}

func Gen(fname string, g *ast.GoGLL) {
	tmpl, err := template.New("Rust symbols").Parse(src)
	if err != nil {
		panic(err)
	}
	buf := new(bytes.Buffer)
	if err := tmpl.Execute(buf, getData(g)); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(fname, buf.Bytes()); err != nil {
		panic(err)
	}
}

func getData(g *ast.GoGLL) *Data {
	return &Data{
		NonTerminals:     g.NonTerminals.ElementsSorted(),
		Terminals:        g.Terminals.ElementsSorted(),
		EscapedTerminals: escape(g.Terminals.ElementsSorted()),
	}
}

// escape terminal for Rust string formatting
func escape(ts []string) []string {
	esc := make([]string, len(ts))
	for i, t := range ts {
		switch t {
		case "{":
			esc[i] = "{{"
		case "}":
			esc[i] = "}}"
		default:
			esc[i] = t
		}
	}
	return esc
}

const src = `// Module symbols is generated by gogll. Do not edit.

use std::fmt;

#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum Symbol {
    NT(NT),
    T(T)
}

// NT is the type of non-terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq, Clone, Copy, Debug)]
pub enum NT { {{range $i, $nt := .NonTerminals}}
    {{$nt}},{{end}}
}

// T is the type of terminals symbols
#[allow(dead_code)]
#[derive(Hash, Eq, PartialEq)]
pub enum T { {{range $i, $t := .Terminals}}
    T{{$i}}, // {{$t}} {{end}}	
}

/// Format a &Vec<Symbol> into a String
#[allow(dead_code)]
pub fn to_string(symbols: &Vec<Symbol>) -> String {
    let mut st: String = "".to_string();
    for sym in symbols.iter() {
        st.push_str(&format!("{} ",sym));
    }
    st
}

impl Symbol {
    #[allow(dead_code)]
    pub fn is_nt(&self) -> bool {
        match self {
            Symbol::NT(_) => return true,
            Symbol::T(_) => return false,
        }
    }
}

impl fmt::Display for NT {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self { {{range $nt := .NonTerminals}} 
            NT::{{$nt}} => write!(f, "{{$nt}}"),{{end}}
        }
    }
}

impl fmt::Display for T {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self { {{range $i, $t := .EscapedTerminals}} 
            T::T{{$i}} => write!(f, "{{$t}}"),{{end}}
        }
    }
}

impl fmt::Display for Symbol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self { 
            Symbol::NT(nt) => write!(f, "{}", nt),
            Symbol::T(t) => write!(f, "{}", t)
        }
    }
}

// ToDo: Delete
// impl fmt::Display for NT {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self { {{range $nt := .NonTerminals}} 
//             NT::{{$nt}} => write!(f, "{{$nt}}"),{{end}}
//         }
//     }
// }

// impl fmt::Display for T {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self { {{range $i, $t := .EscapedTerminals}} 
//             T::T{{$i}} => write!(f, "{{$t}}"),{{end}}
//         }
//     }
// }

// impl fmt::Display for Symbol {
//     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
//         match self { 
//             Symbol::NT(nt) => write!(f, "Symbol::NT({})", nt),
//             Symbol::T(t) => write!(f, "Symbol::T({})", t)
//         }
//     }
// }
`
