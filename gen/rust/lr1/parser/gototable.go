//  Copyright 2020 Marius Ackerman
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package parser

import (
	"bytes"
	"fmt"
	"path"
	"text/template"

	"github.com/goccmack/gogll/lr1/states"
	"github.com/goccmack/gogll/symbols"
	"github.com/goccmack/goutil/ioutil"
)

type gotoTableData struct {
	NumStates    int
	NumNTSymbols int
	States       []*gotoState
}

type gotoState struct {
	Entries []*gotoEntry
}

type gotoEntry struct {
	NT    string
	State string
}

func genGotoTable(outDir string, states *states.States) {
	tmpl, err := template.New("parser goto table").Parse(gotoTableSrc)
	if err != nil {
		panic(err)
	}
	wr := new(bytes.Buffer)
	if err := tmpl.Execute(wr, getGotoTableData(states)); err != nil {
		panic(err)
	}
	if err := ioutil.WriteFile(
		path.Join(outDir, "src", "parser", "goto_table", "mod.rs"),
		wr.Bytes(),
	); err != nil {
		panic(err)
	}
}

func getGotoTableData(states *states.States) *gotoTableData {
	return &gotoTableData{
		NumStates:    states.Size(),
		NumNTSymbols: len(symbols.GetNonTerminalSymbols()),
		States:       getGotoStates(states),
	}
}

func getGotoStates(states *states.States) (res []*gotoState) {
	for _, state := range states.List {
		res = append(res, getGotoState(state))
	}
	return
}

func getGotoState(state *states.State) *gotoState {
	s := &gotoState{}
	for _, nt := range symbols.GetNonTerminalSymbols() {
		s.Entries = append(s.Entries, getGotoEntry(state, nt))
	}
	return s
}

func getGotoEntry(state *states.State, nt string) *gotoEntry {
	e := &gotoEntry{
		NT: nt,
	}
	if nextState := state.Transitions.Transition(nt); nextState == nil {
		e.State = "None"
	} else {
		e.State = fmt.Sprintf("Some(%d)", nextState.Number)
	}
	return e
}

const gotoTableSrc = `//! Generated by GoGLL. Do not edit.

use lazy_static::lazy_static;

lazy_static! { {{$numNT := .NumNTSymbols}}
	pub static ref GOTO_TABLE: Vec<Vec<Option<usize>>> = {
		let m: Vec<Vec<Option<usize>>> = vec![{{range $i, $state := .States}}
			vec![ // S{{$i}} {{range $j, $entry := $state.Entries}}
				{{$entry.State}}, // {{$entry.NT}} {{end}}
			], {{end}}
		];
		m
	};
}
`
